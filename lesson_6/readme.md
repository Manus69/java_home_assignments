# SOLID PRINCIPLES

## Single Responsibility

Соблюдается в классах Student, Teacher, StudentGroup.
User - под вопросом, так как он по какой-то причине определяет equals, хотя, для сравнения Юзеров уже существует специальный класс UserComparator.
Нарушается в StudentController - количество причин для изменения у этого класса равно как минимум количесву конкретных классов, которые он хранит в своих полях, хотя, если верить Бобу Мартину, причина для изменения может быть только одна. 
Нарушается в StudentGroupService - почему класс сортирует списки, которые возвращает? Почему метод getStudent кидает исключение?

## Open-Closed

Нарушается в StudentController - из-за использования конкретных классов, почти любое изменение поведения контроллера требует изменения его исходного кода. 
Нарушется в User из-за метода equals. Так как возникает coupling с UserComparator - если ожидается, что x.equals(y) вернет true, когда Comparator::compare(x, y) вернет 0, любое изменение в логике UserComparator::compare должно привести к изменению метода equals, или наоборот.

## Liskov Substitution

Соблюдается для классов, имплементирующих интерфейсы. 

## Interface Segregation

Соблюдается для классов, имплементирующих интерфейсы (user-defined интерфейсы не содержат лишних методов, Iterable и Comparator определяют default методы).

## Dependency Inversion

Нарушается в StudentController, так как он зависит от "низкоуровневых" классов StudentService, StudentGroupService, StudentView, инстансы которых он создает в конструкторе. Хотя, если строго следовать доктрине СОЛИД, от должен был бы зависеть от интерфейсов, или абстрактных классов, а конкретные инстансы принимать в конструктор (Dependency injection). 